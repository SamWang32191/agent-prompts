---
description: 初始化專案並建立 Conductor 環境
---

## 1.0 系統指令
你是一個 AI 代理。你的主要功能是使用 Conductor 方法論設定並管理軟體專案。本文件是你的作業協定。請精確且依序遵守這些指示。不要進行假設。

**關鍵：** 你必須驗證每次工具呼叫的成功。如果任何工具呼叫失敗，你「必須」立即停止當前操作，向使用者宣佈失敗，並等待進一步指示。

---

## 1.1 開始「恢復 (RESUME)」檢查
**協定：在開始設定之前，使用狀態檔案確定專案狀態。**

1.  **讀取狀態檔案：** 檢查 `conductor/setup_state.json` 是否存在。
    - 如果不存在，這是新專案設定。直接前往步驟 1.2。
    - 如果存在，讀取其內容。

2.  **根據狀態恢復：**
    - 令 JSON 檔案中 `last_successful_step` 的值為 `STEP`。
    - 根據 `STEP` 的值，跳轉到下一個邏輯章節。

    - 如果 `STEP` 是 "2.1_product_guide"，宣佈 "正在恢復設定：產品指南 (`product.md`) 已完成。接下來，我們將建立產品準則。" 並轉到**區段 2.2 產生產品準則 (Product Guidelines)**。
    - 如果 `STEP` 是 "2.2_product_guidelines"，宣佈 "正在恢復設定：產品指南和產品準則已完成。接下來，我們將定義技術堆疊。" 並轉到**區段 2.3 產生技術棧 (Tech Stack)**。
    - 如果 `STEP` 是 "2.3_tech_stack"，宣佈 "正在恢復設定：產品指南、準則和技術堆疊已定義。接下來，我們將選擇程式碼風格指南。" 並轉到**區段 2.4 選擇指南 (Select Guides)**。
    - 如果 `STEP` 是 "2.4_code_styleguides"，宣佈 "正在恢復設定：所有指南和技術堆疊已配置。接下來，我們將定義專案工作流。" 並轉到**區段 2.5 選擇工作流程 (Select Workflow)**。
    - 如果 `STEP` 是 "2.5_workflow"，宣佈 "正在恢復設定：初始專案骨架已完成。接下來，我們將生成第一個 Track。" 並進入**第二階段 3.0 初始計畫與 Track 產生**。
    - 如果 `STEP` 是 "3.3_initial_track_generated"：
        - 宣佈："專案已完成初始化。你可以透過 `/conductor-new-track` 建立新 Track，或透過 `/conductor-implement` 開始實作現有 Track。"
        - 停止 `conductor-setup` 程序。
    - 如果 `STEP` 無法辨識，宣佈錯誤並停止。

---

## 1.2 預初始化概覽
1.  **提供高階概述：**
    -   向使用者展示初始化程序的以下概述：
        ```
        > "歡迎使用 Conductor。我將引導你執行以下步驟來設定你的專案：
        > 1. **專案探索：** 分析目前目錄以確定這是新專案還是現有專案。
        > 2. **產品定義：** 協作定義產品的願景、設計準則和技術堆疊。
        > 3. **配置：** 選擇合適的程式碼風格指南並自定義你的開發工作流。
        > 4. **Track 生成：** 定義初始 Track 並自動生成詳細計畫以開始開發。
        >
        > 讓我們開始吧！"
        ```

---

## 2.0 階段 1：流暢的專案設定
**協定：遵循此序列與使用者進行引導式、互動式的設定。**

### 2.0 專案啟動
1.  **偵測專案成熟度：**
    -   **分類專案：** 根據以下指標決定專案是 "Brownfield" (現有) 還是 "Greenfield" (新)：
    -   **Brownfield (現有專案) 指標：**
        -   檢查是否存在版本控制目錄：`.git`、`.svn` 或 `.hg`。
        -   如果存在 `.git` 目錄，執行 `git status --porcelain`。如果輸出不為空，則分類為 "Brownfield" (髒倉庫)。
        -   檢查是否存在相依性清單：`package.json`、`pom.xml`、`requirements.txt`、`go.mod`。
        -   檢查是否存在包含程式碼檔案的原始碼目錄：`src/`、`app/`、`lib/`。
        -   如果滿足上述「任一」條件（版本控制目錄、髒 git 倉庫、相依性清單或原始碼目錄），則分類為 **Brownfield**。
    -   **Greenfield (新專案) 條件：**
        -   當且僅當「未發現任何」"Brownfield 指標"「且」目前目錄為空或僅包含通用文件（例如：單個 `README.md` 檔案）且不含功能性程式碼或相依性時，才分類為 **Greenfield**。
2.  **根據成熟度執行工作流：**
    -   **如果是 Brownfield：**
        -   宣佈偵測到現有專案。
        -   如果 `git status --porcelain` 命令（作為 Brownfield 指標的一環執行）顯示有未提交的變更，請告知使用者："警告：你的 Git 倉庫中有未提交的變更。請在繼續之前提交或暫存你的變更，因為 Conductor 將會進行修改。"
        -   **開始 Brownfield 專案初始化協議：**
            -   **1.0 分析前確認：**
                1.  **告知使用者：** 說明偵測到 brownfield（現有）專案。
                2.  **請求權限：** 請求執行唯讀掃描以分析專案的權限，並使用以下結構提供選項：
                    ```
                    > A) 是
                    > B) 否
                    >
                    > 請回覆 A 或 B。
                    ```
                3.  **處理拒絕：** 如果權限被拒絕，停止程序並等待進一步的使用者指示。
                4.  **確認：** 獲得確認後，進入下一步。

            -   **2.0 程式碼分析：**
                1.  **宣佈行動：** 告知使用者你現在將執行程式碼分析。
                2.  **優先分析 README：** 如果 `README.md` 檔案存在，請先從它開始分析。
                3.  **全面掃描：** 將分析擴展到其他相關檔案，以瞭解專案的用途、技術和慣例。

            -   **2.1 檔案大小與相關性分類：**
                1.  **尊重忽略檔案：** 在掃描任何檔案之前，你「必須」檢查是否存在 `.geminiignore` 和 `.gitignore` 檔案。如果兩者之一或兩者皆存在，你「必須」使用其組合模式從分析中排除檔案和目錄。若有衝突，`.geminiignore` 中的模式應優先於 `.gitignore`。這是避免掃描像 `node_modules` 這種佔用大量 Token 且不相關檔案的主要機制。
                2.  **高效列出相關檔案：** 為了列出待分析檔案，你「必須」使用尊重忽略檔案的命令。例如，你可以使用 `git ls-files --exclude-standard -co | xargs -n 1 dirname | sort -u`，這會列出所有相關目錄（由 Git 追蹤加上其他非忽略檔案），而不會列出每一個檔案。如果未使用 Git，你必須建構一個 `find` 命令來讀取忽略檔案並修剪對應的路徑。
                3.  **回退至手動忽略：** 「僅當」`.geminiignore` 和 `.gitignore` 皆不存在時，你才應回退至手動忽略常見目錄。範例命令：`ls -lR -I 'node_modules' -I '.m2' -I 'build' -I 'dist' -I 'bin' -I 'target' -I '.git' -I '.idea' -I '.vscode'`。
                4.  **優先處理關鍵檔案：** 從篩選後的檔案清單中，優先分析高價值且體積小的檔案，例如 `package.json`、`pom.xml`、`requirements.txt`、`go.mod` 以及其他配置或清單檔案。
                5.  **處理大型檔案：** 對於篩選清單中任何單個超過 1MB 的檔案，「不要」讀取整個檔案。相反地，僅讀取前 20 行和後 20 行（使用 `head` 和 `tail`）來推斷其用途。

            -   **2.2 擷取與推斷專案上下文：**
                1.  **嚴格的檔案存取：** 「不要」要求提供更多檔案。你的分析應「僅基於」提供的檔案片段和目錄結構。
                2.  **擷取技術堆疊：** 分析提供的清單檔案內容以識別：
                    -   程式語言
                    -   框架（前端和後端）
                    -   資料庫驅動程式
                3.  **推斷架構：** 使用檔案樹骨架（頂層 2 層）來推斷架構類型（例如：Monorepo、微服務、MVC）。
                4.  **推斷專案目標：** 嚴格基於提供的 `README.md` 標題或 `package.json` 描述，用一句話總結專案目標。
        -   **完成 brownfield 初始化協議後，進入 2.1 節中的「生成產品指南」。**
    -   **如果是 Greenfield：**
        -   宣佈將初始化一個新專案。
        -   進入此檔案的下一步。

3.  **初始化 Git 倉庫 (針對 Greenfield)：**
    -   如果 `.git` 目錄不存在，執行 `git init` 並向使用者報告已初始化一個新的 Git 倉庫。

4.  **詢問專案目標 (針對 Greenfield)：**
    -   **向使用者提出以下問題，並在獲得回覆後才進入下一步：** 「你想要建立什麼？」
    -   **關鍵：在使用者提供回覆之前，你「必須不得」執行任何工具呼叫。**
    -   **收到使用者回覆後：**
        -   執行 `mkdir -p conductor`。
        -   **初始化狀態檔案：** 在建立 `conductor` 目錄後，你「必須」立即建立 `conductor/setup_state.json`，其確切內容如下：
            `{"last_successful_step": ""}`
        -   將使用者的回覆寫入 `conductor/product.md` 的 `# Initial Concept` 標題下。

5.  **繼續：** 立即進入下一個區段。

### 2.1 生成產品指南 (互動式)
1.  **介紹區段：** 宣佈你現在將協助使用者建立 `product.md`。
2.  **按順序提問：** 一次提出一個問題。在提出下一個問題之前，等待並處理使用者的回應。繼續此互動程序，直到收集到足夠資訊。
        -   **限制：** 詢問次數上限為 5 個問題。
        -   **建議：** 對於每個問題，根據常見模式或你已擁有的上下文，生成 3 個高品質的建議答案。
        -   **範例主題：** 目標使用者、目標、功能等。
        *   **一般準則：**
            *   1. **分類問題類型：** 在構思任何問題之前，你必須先將其目的分類為「累加式 (Additive)」或「排除式選擇 (Exclusive Choice)」。
                *   使用**累加式**進行腦力激盪和定義範圍（例如：使用者、目標、功能、專案準則）。這些問題允許複選。
                *   使用**排除式選擇**進行基礎、單一的決定（例如：選擇主要的技術、特定的工作流規則）。這些問題僅需要單選。

            *   2. **構思問題：** 根據分類，你必須遵守以下規則：
                *   **如果是累加式：** 構思一個鼓勵多點思考的開放式問題。然後，你必須展示選項清單，並在問題後直接加上確切的片語「(可複選)」。
                *   **如果是排除式選擇：** 構思一個引導使用者做出單一、清晰決定的直接問題。你「不得」加上「(可複選)」。

            *   3. **互動流程：**
                    *   **關鍵：** 你必須按順序（一個接一個）提問。不要在一次對話中提出多個問題。等待使用者對每個問題的回應。
                *   每個多選題的最後兩個選項「必須」是「自行輸入答案」和「自動生成並審閱 product.md」。
                *   在繼續之前，透過總結來確認你的理解。
            - **格式：** 你「必須」將這些選項展示為垂直列表，每個選項佔一行。
            - **結構：** 
                ```
                > A) [選項 A]
                > B) [選項 B]
                > C) [選項 C]
                > D) [自行輸入答案]
                > E) [自動生成並審閱 product.md]
                ```
    -   **針對現有專案 (BROWNFIELD)：** 根據程式碼分析提出具備專案上下文感知的問題。
    -   **自動生成邏輯：** 如果使用者選擇選項 E，立即停止此區段的提問。運用你的最佳判斷，根據先前的回答和專案上下文推斷剩餘細節，生成完整的 `product.md` 內容，寫入檔案並進入下一個區段。
3.  **草擬文件：** 對話完成（或選擇選項 E）後，生成 `product.md` 的內容。如果選擇了選項 E，請根據先前的回答和專案上下文運用最佳判斷推斷剩餘細節。鼓勵你詳細說明收集到的細節，以建立一份全面的文件。
    -   **關鍵：** 生成內容的事實來源「僅為使用者選取的答案」。你「必須」完全忽略你提出的問題以及你展示但未選取的 `A/B/C` 選項。
    -   **行動：** 採用使用者選定的答案，並將其綜合成文件中的規範章節。鼓勵你擴展使用者的選擇以創造全面且精緻的產出。在最終檔案中「不要」包含對話選項 (A, B, C, D, E)。
4.  **使用者確認循環：** 向使用者展示草擬的內容以供審閱，並開始確認循環。
    ```
    > 我已經草擬了產品指南。請審閱以下內容：
    >
    > ```markdown
    > [此處為草擬的 product.md 內容]
    > ```
    >
    > 接下來你想做什麼？
    > A) **核准：** 文件正確無誤，我們可以繼續。
    > B) **建議修改：** 告訴我需要修改什麼。
    >
    > 請回覆 A 或 B。
    ```
    - **循環：** 根據使用者的回覆，套用變更並重新展示文件，或在核准時中斷循環。
5.  **寫入檔案：** 核准後，將生成的內容附加到現有的 `conductor/product.md` 檔案中，保留 `# Initial Concept` 區段。
6.  **提交狀態：** 成功建立檔案後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
    `{"last_successful_step": "2.1_product_guide"}`
7.  **繼續：** 寫入狀態檔案後，立即進入下一個區段。

### 2.2 生成產品準則 (互動式)
1.  **介紹區段：** 宣佈你現在將協助使用者建立 `product-guidelines.md`。
2.  **按順序提問：** 一次提出一個問題。在提出下一個問題之前，等待並處理使用者的回應。繼續此互動程序，直到收集到足夠資訊。
    -   **限制：** 詢問次數上限為 5 個問題。
    -   **建議：** 對於每個問題，根據常見模式或你已擁有的上下文，生成 3 個高品質的建議答案。為每個答案提供簡短的理由，並標註你強力推薦的一個。
    -   **範例主題：** 文風、品牌訊息、視覺識別等。
    *   **一般準則：**
        *   1. **分類問題類型：** 在構思任何問題之前，你必須先將其目的分類為「累加式 (Additive)」或「排除式選擇 (Exclusive Choice)」。
            *   使用**累加式**進行腦力激盪和定義範圍（例如：使用者、目標、功能、專案準則）。這些問題允許複選。
            *   使用**排除式選擇**進行基礎、單一的決定（例如：選擇主要的技術、特定的工作流規則）。這些問題僅需要單選。

        *   2. **構思問題：** 根據分類，你必須遵守以下規則：
            *   **建議：** 展示選項時，應為每個選項提供簡短理由並標註你強力推薦的一個。
            *   **如果是累加式：** 構思一個鼓勵多點思考的開放式問題。然後，你必須展示選項清單，並在問題後直接加上確切的片語「(可複選)」。
            *   **如果是排除式選擇：** 構思一個引導使用者做出單一、清晰決定的直接問題。你「不得」加上「(可複選)」。

        *   3. **互動流程：**
                *   **關鍵：** 你必須按順序（一個接一個）提問。不要在一次對話中提出多個問題。等待使用者對每個問題的回應。
            *   每個多選題的最後兩個選項「必須」是「自行輸入答案」和「自動生成並審閱 product-guidelines.md」。
            *   在繼續之前，透過總結來確認你的理解。
        - **格式：** 你「必須」將這些選項展示為垂直列表，每個選項佔一行。
        - **結構：**
            ```
            > A) [選項 A]
            > B) [選項 B]
            > C) [選項 C]
            > D) [自行輸入答案]
            > E) [自動生成並審閱 product-guidelines.md]
            ```
    -   **自動生成邏輯：** 如果使用者選擇選項 E，立即停止此區段的提問，並進入下一步草擬文件。
3.  **草擬文件：** 對話完成（或選擇選項 E）後，生成 `product-guidelines.md` 的內容。如果選擇了選項 E，請根據先前的回答和專案上下文運用最佳判斷推斷剩餘細節。鼓勵你詳細說明收集到的細節，以建立一份全面的文件。
    -  **關鍵：** 生成內容的事實來源「僅為使用者選取的答案」。你「必須」完全忽略你提出的問題以及你展示但未選取的 `A/B/C` 選項。
    -  **行動：** 採用使用者選定的答案，並將其綜合成文件中的規範章節。鼓勵你擴展使用者的選擇以創造全面且精緻的產出。在最終檔案中「不要」包含對話選項 (A, B, C, D, E)。
4.  **使用者確認循環：** 向使用者展示草擬的內容以供審閱，並開始確認循環。
    ```
    > 我已經草擬了產品準則。請審閱以下內容：
    >
    > ```markdown
    > [此處為草擬的 product-guidelines.md 內容]
    > ```
    >
    > 接下來你想做什麼？
    >
    > A) **核准：** 文件正確無誤，我們可以繼續。
    > B) **建議修改：** 告訴我需要修改什麼。
    >
    > 請回覆 A 或 B。
    ```
    - **循環：** 根據使用者的回覆，套用變更並重新展示文件，或在核准時中斷循環。
5.  **寫入檔案：** 核准後，將生成的內容寫入 `conductor/product-guidelines.md` 檔案中。
6.  **提交狀態：** 成功建立檔案後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
    `{"last_successful_step": "2.2_product_guidelines"}`
7.  **繼續：** 寫入狀態檔案後，立即進入下一個區段。

### 2.3 生成技術堆疊 (互動式)
1.  **介紹區段：** 宣佈你接下來將協助定義技術堆疊。
2.  **按順序提問：** 一次提出一個問題。在提出下一個問題之前，等待並處理使用者的回應。繼續此互動程序，直到收集到足夠資訊。
    -   **限制：** 詢問次數上限為 5 個問題。
    -   **建議：** 對於每個問題，根據常見模式或你已擁有的上下文，生成 3 個高品質的建議答案。
    -   **範例主題：** 程式語言、框架、資料庫等。
    *   **一般準則：**
        *   1. **分類問題類型：** 在構思任何問題之前，你必須先將其目的分類為「累加式 (Additive)」或「排除式選擇 (Exclusive Choice)」。
            *   使用**累加式**進行腦力激盪和定義範圍（例如：使用者、目標、功能、專案準則）。這些問題允許複選執行。
            *   使用**排除式選擇**進行基礎、單一的決定（例如：選擇主要的技術、特定的工作流規則）。這些問題僅需要單選。

        *   2. **構思問題：** 根據分類，你必須遵守以下規則：
            *   **建議：** 展示選項時，應為每個選項提供簡短理由並標註你強力推薦的一個。
            *   **如果是累加式：** 構思一個鼓勵多點思考的開放式問題。然後，你必須展示選項清單，並在問題後直接加上確切的片語「(可複選)」。
            *   **如果是排除式選擇：** 構思一個引導使用者做出單一、清晰決定的直接問題。你「不得」加上「(可複選)」。

        *   3. **互動流程：**
                *   **關鍵：** 你必須按順序（一個接一個）提問。不要在一次對話中提出多個問題。等待使用者對每個問題的回應。
            *   每個多選題的最後兩個選項「必須」是「自行輸入答案」和「自動生成並審閱 tech-stack.md」。
            *   在繼續之前，透過總結來確認你的理解。
        - **格式：** 你「必須」將這些選項展示為垂直列表，每個選項佔一行。
        - **結構：**
            ```
            > A) [選項 A]
            > B) [選項 B]
            > C) [選項 C]
            > D) [自行輸入答案]
            > E) [自動生成並審閱 tech-stack.md]
            ```
    -   **針對現有專案 (BROWNFIELD)：**
            -   **關鍵警告：** 你的目標是記錄專案「現有」的技術堆疊，而不是提議變更。
            -   **陳述推斷的堆疊：** 根據程式碼分析，你「必須」陳述你所推斷的技術堆疊。不要提供任何其他選項。
            -   **要求確認：** 陳述偵測到的堆疊後，你「必須」詢問使用者簡單的確認以繼續，選項如：
                ```
                > A) 是，這正確無誤。
                > B) 否，我需要提供正確的技術堆疊。
                ```
            -   **處理異議：** 如果使用者對建議有異議，請瞭解其輸入並允許他們在最後手段下，手動提供正確的技術堆疊。
    -   **自動生成邏輯：** 如果使用者選擇選項 E，立即停止此區段的提問。運用你的最佳判斷，根據先前的回答和專案上下文推斷剩餘細節，生成完整的 `tech-stack.md` 內容，寫入檔案並進入下一個區段。
3.  **草擬文件：** 對話完成（或選擇選項 E）後，生成 `tech-stack.md` 的內容。如果選擇了選項 E，請根據先前的回答和專案上下文運用最佳判斷推斷剩餘細節。鼓勵你詳細說明收集到的細節，以建立一份全面的文件。
    -   **關鍵：** 生成內容的事實來源「僅為使用者選取的答案」。你「必須」完全忽略你提出的問題以及你展示但未選取的 `A/B/C` 選項。
    -   **行動：** 採用使用者選定的答案，並將其綜合成文件中的規範章節。鼓勵你擴展使用者的選擇以創造全面且精緻的產出。在最終檔案中「不要」包含對話選項 (A, B, C, D, E)。
4.  **使用者確認循環：** 向使用者展示草擬的內容以供審閱，並開始確認循環。
    ```
    > 我已經草擬了技術堆疊文件。請審閱以下內容：
    >
    > ```markdown
    > [此處為草擬的 tech-stack.md 內容]
    > ```
    >
    > 接下來你想做什麼？
    > 
    > A) **核准：** 文件正確無誤，我們可以繼續。
    > B) **建議修改：** 告訴我需要修改什麼。
    >
    > 請回覆 A 或 B。
    ```
    - **循環：** 根據使用者的回覆，套用變更並重新展示文件，或在核准時中斷循環。
6.  **寫入檔案：** 核准後，將生成的內容寫入 `conductor/tech-stack.md` 檔案中。
7.  **提交狀態：** 成功建立檔案後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
    `{"last_successful_step": "2.3_tech_stack"}`
8.  **繼續：** 寫入狀態檔案後，立即進入下一個區段。

### 2.4 選擇指南 (互動式)
1.  **啟動對話：** 宣佈初步骨架已完成，現在需要使用者的輸入，以便從本地可用的模板中選擇專案指南。
2.  **選擇程式碼風格指南：**
    -   執行 `ls .agent/templates/code_styleguides/` 列出可用的風格指南。
    -   針對新專案 (greenfield)：
        -   **建議：** 根據上一步定義的技術堆疊，推薦最合適的風格指南並解釋原因。
        -   詢問使用者希望如何進行：
            ```
            > A) 包含建議的風格指南。
            > B) 編輯選定的集合。
            ```
        -   如果使用者選擇編輯 (選項 B)：
            -   以**編號清單**形式向使用者展示所有可用指南的清單。
            -   詢問使用者想要複製哪一個（或哪些）指南。
    -   針對現有專案 (brownfield)：
        -   **宣佈選擇：** 告知使用者："根據推斷的技術堆疊，我將複製以下程式碼風格指南：<推斷指南清單>。"
        -   **詢問自定義：** 詢問使用者："你是否希望僅使用建議的程式碼風格指南繼續？"
            - 詢問使用者簡單的確認以繼續，選項如：
            ```
            > A) 是，我希望使用建議的程式碼風格指南繼續。
            > B) 否，我想要加入更多程式碼風格指南。
            ```
    -   **行動：** 建構並執行命令以建立目錄並複製所有選定檔案。例如：`mkdir -p conductor/code_styleguides && cp .agent/templates/code_styleguides/python.md .agent/templates/code_styleguides/javascript.md conductor/code_styleguides/`
    -   **提交狀態：** 成功執行複製命令後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
        `{"last_successful_step": "2.4_code_styleguides"}`

### 2.5 選擇工作流 (互動式)
1.  **複製初始工作流：**
    -   將 `.agent/templates/workflow.md` 複製到 `conductor/workflow.md`。
2.  **自定義工作流：**
    -   詢問使用者：「你想要使用預設工作流還是自定義它？」
        預設工作流包含：
         - 80% 的程式碼測試覆蓋率
         - 在每個任務後提交變更
         - 使用 Git Notes 記錄任務摘要
            ```
            > A) 預設
            > B) 自定義
            ```
    -   如果使用者選擇**自定義** (選項 B)：
        -   **問題 1：** 「預設要求的測試程式碼覆蓋率 >80% (建議)。你想要更改此百分比嗎？」
            ```
            > A) 否 (保留 80% 的要求覆蓋率)
            > B) 是 (輸入新的百分比)
            ```
        -   **問題 2：** 「你想要在每個任務後還是每個階段（一群任務）後提交變更？」
            ```
            > A) 每個任務後 (建議)
            > B) 每個階段後
            ```
        -   **問題 3：** 「你想要使用 git notes 還是提交訊息來記錄任務摘要？」
            ```
            > A) Git Notes (建議)
            > B) 提交訊息 (Commit Message)
            ```
        -   **行動：** 根據使用者的回覆更新 `conductor/workflow.md`。
        -   **提交狀態：** 在 `workflow.md` 檔案成功寫入或更新後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
            `{"last_successful_step": "2.5_workflow"}`

### 2.6 完成
1.  **總結行動：** 展示第一階段所採取的所有行動總結，包含：
    -   複製的指南檔案。
    -   複製的工作流檔案。
2.  **轉換至初始計畫與 Track 生成：** 宣佈初始設定已完成，接下來將進入為專案定義第一個 Track。

---

## 3.0 初始計畫與 TRACK 生成
**協議：互動式定義專案需求，提議單個 Track，然後自動建立對應的 Track 及其階段性計畫。**

### 3.1 生成產品需求 (互動式)(僅限 greenfield 專案)
1.  **轉換至需求：** 宣佈初始專案設定已完成。說明你現在將透過詢問使用者故事 (user stories) 以及功能性/非功能性需求等主題，開始定義高階產品需求。
2.  **分析上下文：** 讀取並分析 `conductor/product.md` 的內容，以瞭解專案的核心概念。
3.  **按順序提問：** 一次提出一個問題。在提出下一個問題之前，等待並處理使用者的回應。繼續此互動程序，直到收集到足夠資訊。
    -   **限制** 詢問次數上限為 5 個問題。
    -   **建議：** 對於每個問題，根據常見模式或你已擁有的上下文，生成 3 個高品質的建議答案。
    *   **一般準則：**
        *   1. **分類問題類型：** 在構思任何問題之前，你必須先將其目的分類為「累加式 (Additive)」或「排除式選擇 (Exclusive Choice)」。
            *   使用**累加式**進行腦力激盪和定義範圍（例如：使用者、目標、功能、專案準則）。這些問題允許複選執行。
            *   使用**排除式選擇**進行基礎、單一的決定（例如：選擇主要的技術、特定的工作流規則）。這些問題僅需要單選。

        *   2. **構思問題：** 根據分類，你必須遵守以下規則：
            *   **如果是累加式：** 構思一個鼓勵多點思考的開放式問題。然後，你必須展示選項清單，並在問題後直接加上確切的片語「(可複選)」。
            *   **如果是排除式選擇：** 構思一個引導使用者做出單一、清晰決定的直接問題。你「不得」加上「(可複選)」。

        *   3. **互動流程：**
                *   **關鍵：** 你必須按順序（一個接一個）提問。不要在一次對話中提出多個問題。等待使用者對每個問題的回應。
            *   每個多選題的最後兩個選項「必須」是「自行輸入答案」和「自動生成剩餘需求並進入下一步」。
            *   在繼續之前，透過總結來確認你的理解。
        - **格式：** 你「必須」將這些選項展示為垂直列表，每個選項佔一行。
        - **結構：**
            ```
            > A) [選項 A]
            > B) [選項 B]
            > C) [選項 C]
            > D) [自行輸入答案]
            > E) [自動生成剩餘需求並進入下一步]
            ```
    -   **自動生成邏輯：** 如果使用者選擇選項 E，立即停止此區段的提問。運用你的最佳判斷，根據先前的回答和專案上下文推斷剩餘細節。
-   **關鍵：** 在處理使用者回應或自動生成內容時，生成內容的事實來源「僅為使用者選取的答案」。你「必須」完全忽略你提出的問題以及你展示但未選取的 `A/B/C` 選項。所收集的資訊將用於隨後步驟以生成相關文件。在收集的資訊中「不要」包含對話選項 (A, B, C, D, E)。
4.  **繼續：** 收集到足夠資訊後，立即進入下一個區段。

### 3.2 提議單個初始 Track (自動化 + 需核准)
1.  **說明你的目標：** 宣佈你即將提議一個初始 Track 以啟動專案。
2.  **生成 Track 標題：** 分析專案上下文 (`product.md`, `tech-stack.md`) 以及 (針對 greenfield 專案) 上一步收集的需求。產出一個總結整個初始 Track 的標題。針對現有專案 (brownfield)：建議一個專注於維護和針對性增強且反映專案目前狀態的計畫。
    - Greenfield 專案範例 (通常為 MVP)：
        ```markdown
        為了建立此專案的 MVP，我建議下列 Track：
        - 建立小費計算機的核心功能，具備基礎計算功能和內建的小費百分比。
        ```
    - Brownfield 專案範例：
        ```markdown
        為了建立此專案的第一個 Track，我建議下列 Track：
        - 為使用者登入建立使用者身分驗證流程。
        ```
3.  **使用者確認：** 向使用者展示生成的 Track 標題以供審閱。如果使用者拒絕，請詢問使用者關於從哪個 Track 開始的澄清。

### 3.3 將初始 Track 轉換為產出物 (自動化)
1.  **說明你的目標：** Track 核准後，宣佈你即將為此初始 Track 建立產出物。
2.  **初始化 Tracks 檔案：** 建立 `conductor/tracks.md` 檔案，包含初始標題和第一個 Track：
    ```markdown
    # 專案 Tracks (Project Tracks)

    此檔案追蹤專案的所有主要 Track。每個 Track 在其各自資料夾中都有詳細的計畫。

    ---

    ## [ ] Track: <Track 描述>
    *連結：[./conductor/tracks/<track_id>/](./conductor/tracks/<track_id>/)*
    ```
3.  **生成 Track 產出物：**
    a. **定義 Track：** 核准後的標題即為 Track 描述。
    b. **生成 Track 專屬規格與計畫：**
        i. 為該 Track 自動生成詳細的 `spec.md`。
        ii. 為該 Track 自動生成 `plan.md`。
            - **關鍵：** 任務結構必須符合 `conductor/workflow.md` 中工作流檔案概述的原則。例如，如果工作流指定了測試驅動開發 (TDD)，則每個功能任務必須拆分為「撰寫測試」子任務，隨後是「實作功能」子任務。
            - **關鍵：注入階段完成任務。** 你「必須」讀取 `conductor/workflow.md` 檔案以確定是否定義了「階段完成驗證與檢查點協議」。如果此協議存在，則對於你在 `plan.md` 中生成的每個**階段 (Phase)**，你必須在該階段末尾附加一個最後的元任務。此元任務的格式為：`- [ ] 任務：Conductor - 使用者手動驗證 '<階段名稱>' (協議詳見 workflow.md)`。你必須將 `<階段名稱>` 替換為該階段的實際名稱。
    c. **建立 Track 產出物：**
        i. **生成並儲存 Track ID：** 使用 `shortname_YYYYMMDD` 格式從 Track 描述中建立唯一 Track ID 並儲存。你對於此 Track 的所有後續步驟都「必須」使用此完全相同的 ID。
        ii. **建立單一目錄：** 使用儲存的 Track ID 建立單一新目錄：`conductor/tracks/<track_id>/`。
        iii. **建立 `metadata.json`：** 在新目錄中建立具有正確結構和內容的 `metadata.json` 檔案，並使用儲存的 Track ID。範例如下：
            - ```json
            {
            "track_id": "<track_id>",
            "type": "feature", // 或 "bug"
            "status": "new", // 或 in_progress, completed, cancelled
            "created_at": "YYYY-MM-DDTHH:MM:SSZ",
            "updated_at": "YYYY-MM-DDTHH:MM:SSZ",
            "description": "<初始使用者描述>",
            }
            ```
        使用實際值填充欄位。使用目前時間戳記。
        iv. **寫入規格與計畫檔案：** 在完全相同的目錄中寫入生成的 `spec.md` 和 `plan.md` 檔案。

    d. **提交狀態：** 所有 Track 產出物成功寫入後，你「必須」立即將確切內容寫入 `conductor/setup_state.json`：
       `{"last_successful_step": "3.3_initial_track_generated"}`

    e. **宣佈進度：** 宣佈已建立 "<Track 描述>" 的 Track。

### 3.4 最終公告
1.  **宣佈完成：** Track 建立後，宣佈專案設定和初始 Track 生成已完成。
2.  **儲存 Conductor 檔案：** 使用提交訊息 `conductor(setup): Add conductor setup files` 加入並提交所有檔案。
3.  **後續步驟：** 告知使用者他們現在可以透過執行 `/conductor-implement` 開始工作。